#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#define MIN(a, b) (((a) < (b)) ? (a) : (b))

extern void dgetrf_(int* M, int *N, double* A, int* lda, int* IPIV, int* INFO);
extern void dgetri_(int* N, double* A, int* lda, int* IPIV, double* WORK, int* lwork, int* INFO);

double** convertEnergyGridToTransitionMatrix(int*, int*, double*, int);
double computeMFPT(int*, int*, double**, int);
void inverse(double*, int);

int main(int argc, char *argv[]) {
  // puts RNA.from_fasta("./benchmarking/giegerich_seqs/spliced_leader.txt").run(:fftbor2d).distribution.map { |r| [r.i, r.j, "%.8f" % r.p] }.transpose.map { |a| "{ %s };" % a.join(", ") }
  int k[]    = { 0, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 37, 37, 38, 38, 38, 38, 38, 38, 38 };
  int l[]    = { 29, 28, 30, 27, 29, 31, 26, 28, 30, 25, 27, 29, 31, 33, 24, 26, 28, 30, 23, 25, 27, 29, 31, 33, 22, 24, 26, 28, 30, 34, 21, 23, 25, 27, 29, 31, 35, 20, 22, 24, 26, 28, 30, 32, 36, 19, 21, 23, 25, 27, 29, 31, 33, 37, 18, 20, 22, 24, 26, 28, 30, 34, 38, 17, 19, 21, 23, 25, 27, 29, 33, 37, 16, 20, 22, 24, 26, 28, 30, 34, 38, 15, 17, 19, 21, 23, 25, 27, 29, 31, 35, 16, 20, 22, 24, 26, 28, 30, 32, 36, 13, 17, 19, 21, 23, 25, 27, 29, 33, 37, 12, 14, 18, 20, 22, 24, 26, 28, 30, 34, 38, 11, 15, 19, 21, 23, 25, 27, 29, 31, 35, 12, 16, 18, 20, 22, 24, 26, 28, 30, 32, 36, 9, 13, 15, 17, 21, 23, 25, 27, 29, 33, 37, 8, 10, 14, 16, 18, 20, 22, 24, 26, 28, 30, 34, 38, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 31, 35, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 32, 36, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 29, 33, 37, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 30, 34, 38, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 31, 35, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 28, 32, 36, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 29, 33, 37, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 30, 34, 38, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 31, 35, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 32, 36, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 33, 37, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 26, 28, 30, 34, 38, 5, 7, 9, 11, 13, 15, 17, 19, 23, 27, 31, 35, 6, 8, 10, 12, 14, 16, 18, 20, 24, 28, 32, 36, 7, 9, 11, 13, 15, 17, 19, 21, 25, 29, 33, 37, 10, 14, 18, 22, 26, 30, 34, 38, 11, 15, 19, 23, 27, 31, 35 };
  double p[] = { 0.17130677, 0.06694292, 0.00143948, 0.18330607, 0.00241379, 0.00155001, 0.08363250, 0.00589261, 0.00061249, 0.01879275, 0.00635816, 0.01471148, 0.00001672, 0.00000001, 0.02752008, 0.00232164, 0.00690156, 0.00044524, 0.01257039, 0.00313642, 0.00194263, 0.00702272, 0.00003173, 0.00000001, 0.00303956, 0.00167094, 0.00377133, 0.00254657, 0.00006054, 0.00000003, 0.00339286, 0.00039550, 0.00208775, 0.02981406, 0.00006722, 0.00001711, 0.00000007, 0.00111311, 0.00055416, 0.00060088, 0.01218476, 0.00131861, 0.00000668, 0.00000015, 0.00000013, 0.00012676, 0.00018052, 0.00191732, 0.00251378, 0.00095047, 0.00008625, 0.00000016, 0.00000015, 0.00000016, 0.00000828, 0.00001999, 0.00060045, 0.00594502, 0.00037693, 0.00011399, 0.00000302, 0.00000008, 0.00000013, 0.00000027, 0.00000408, 0.00005755, 0.00184532, 0.00464004, 0.00070285, 0.00000730, 0.00000011, 0.00000003, 0.00000075, 0.00000722, 0.00017295, 0.00170631, 0.01929939, 0.00005496, 0.00000077, 0.00000030, 0.00000022, 0.00000010, 0.00000007, 0.00000118, 0.00001137, 0.00020318, 0.00616050, 0.00911656, 0.00000302, 0.00000034, 0.00000025, 0.00000028, 0.00000267, 0.00001141, 0.00055345, 0.00390815, 0.00167960, 0.00000013, 0.00000001, 0.00000002, 0.00000005, 0.00000004, 0.00000022, 0.00000162, 0.00002259, 0.00055123, 0.00368600, 0.00007075, 0.00000005, 0.00000004, 0.00000003, 0.00000005, 0.00000010, 0.00000028, 0.00000466, 0.00003142, 0.00097097, 0.00062204, 0.00000755, 0.00000004, 0.00000004, 0.00000005, 0.00000007, 0.00000013, 0.00000045, 0.00000344, 0.00006774, 0.00018185, 0.00002504, 0.00000028, 0.00000003, 0.00000004, 0.00000012, 0.00000007, 0.00000014, 0.00000060, 0.00000306, 0.00001400, 0.00000788, 0.00000242, 0.00000002, 0.00000002, 0.00000005, 0.00000004, 0.00000009, 0.00000039, 0.00000019, 0.00000117, 0.00000075, 0.00000084, 0.00000077, 0.00000002, 0.00000002, 0.00000020, 0.00000004, 0.00000009, 0.00000027, 0.00000004, 0.00000002, 0.00000038, 0.00000069, 0.00000021, 0.00000005, 0.00000004, 0.00000001, 0.00000001, 0.00000149, 0.00000012, 0.00000007, 0.00000001, 0.00000015, 0.00000100, 0.00000008, 0.00000005, 0.00000032, 0.00000066, 0.00000004, 0.00000001, 0.00000001, 0.00000591, 0.00000145, 0.00000019, 0.00000013, 0.00000005, 0.00000004, 0.00001494, 0.00000003, 0.00000007, 0.00000037, 0.00000009, 0.00000001, 0.00000001, 0.00000001, 0.00001705, 0.00002050, 0.00000225, 0.00000070, 0.00000035, 0.00000028, 0.00000023, 0.00001244, 0.00000002, 0.00000007, 0.00000013, 0.00000001, 0.00000001, 0.00000001, 0.00002629, 0.00021829, 0.00006630, 0.00000776, 0.00000149, 0.00000168, 0.00000228, 0.00000016, 0.00000592, 0.00000002, 0.00000004, 0.00000003, 0.00000001, 0.00000001, 0.00000001, 0.00030296, 0.00010381, 0.00075156, 0.00009365, 0.00001018, 0.00000150, 0.00000130, 0.00000157, 0.00000012, 0.00000756, 0.00000002, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00326861, 0.00132716, 0.00003687, 0.00071909, 0.00014593, 0.00001300, 0.00000223, 0.00000107, 0.00000118, 0.00000026, 0.00005938, 0.00000002, 0.00000001, 0.00000001, 0.00000001, 0.02365929, 0.01125352, 0.00034794, 0.00008083, 0.00132827, 0.00012890, 0.00002326, 0.00000440, 0.00000073, 0.00000066, 0.00000020, 0.00004081, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.07611287, 0.04416203, 0.00191785, 0.00073775, 0.00010594, 0.00062831, 0.00009021, 0.00003778, 0.00000266, 0.00000038, 0.00000023, 0.00000006, 0.00001247, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00234371, 0.00794409, 0.00480234, 0.00100281, 0.00011485, 0.00037612, 0.00011145, 0.00002638, 0.00000090, 0.00000024, 0.00000010, 0.00000004, 0.00000307, 0.00000001, 0.00000001, 0.00000001, 0.02179160, 0.01963585, 0.00500676, 0.00055858, 0.00002926, 0.00018835, 0.00004172, 0.00000690, 0.00000037, 0.00000008, 0.00000007, 0.00000002, 0.00000165, 0.00000001, 0.00000001, 0.00000001, 0.00237453, 0.00203222, 0.00048152, 0.00007446, 0.00000510, 0.00007170, 0.00000947, 0.00000263, 0.00000016, 0.00000002, 0.00000004, 0.00000001, 0.00000055, 0.00000001, 0.00000001, 0.00000001, 0.00208330, 0.00212716, 0.00051586, 0.00004181, 0.00000513, 0.00005993, 0.00000691, 0.00000100, 0.00000004, 0.00000001, 0.00000001, 0.00000008, 0.00000001, 0.00000001, 0.00000001, 0.00281278, 0.00186143, 0.00021169, 0.00003994, 0.00000332, 0.00002559, 0.00000449, 0.00000048, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00051560, 0.00057288, 0.00019315, 0.00002488, 0.00000095, 0.00001017, 0.00000318, 0.00000007, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00053147, 0.00047134, 0.00010040, 0.00000270, 0.00000040, 0.00000261, 0.00000080, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00000001, 0.00000001 };
  int length = 399;
  double** transitionMatrix;
  double mfpt;
  
  transitionMatrix = convertEnergyGridToTransitionMatrix(k, l, p, length);
  mfpt             = computeMFPT(k, l, transitionMatrix, length);
  
  printf("MFPT: %f (should be 551.859572)\n", mfpt);

  return 0;
}

double** convertEnergyGridToTransitionMatrix(int* k, int* l, double* p, int length) {
  int i, j;
  double rowSum;
  double** transitionProbabilities = (double**)malloc(length * sizeof(double*));
  
  for (i = 0; i < length; ++i) {
    rowSum = 0.;
    
    transitionProbabilities[i] = (double*)malloc(length * sizeof(double));
      
    for (j = 0; j < length; ++j) {
      if (i != j) {
        transitionProbabilities[i][j] = MIN(
          1., 
          p[j] / p[i]
        ) / (length - 1);
        
        rowSum += transitionProbabilities[i][j];
      }
    }
    
    transitionProbabilities[i][i] = 1 - rowSum;
  }
  
  return transitionProbabilities;
}

double computeMFPT(int* k, int* l, double **transitionProbabilities, int length) {
  int i, j, x, y, startIndex, endIndex, inversionMatrixRowLength = length - 1;
  double mfptFromStart;
  
  for (i = 0, startIndex = -1, endIndex = -1; i < length; ++i) {
    if (k[i] == 0) {
      startIndex = i;
    }
    
    if (l[i] == 0) {
      endIndex = i;
    }
  }
  
  if (startIndex < 0) {
    fprintf(stderr, "We can not find any position in the energy grid correspondent to the starting state.\n");
    return -1;
  }
  
  if (endIndex < 0) {
    fprintf(stderr, "We can not find any position in the energy grid correspondent to the ending state.\n");
    return -2;
  }
  
  double *mfpt            = (double*)malloc(inversionMatrixRowLength * sizeof(double));
  double *inversionMatrix = (double*)malloc((int)pow((double)inversionMatrixRowLength, 2.) * sizeof(double));
  
  // If startIndex > endIndex, we need to shift to the left by one because the endIndex row / column is being removed.
  if (startIndex > endIndex) {
    startIndex--;
  }
  
  for (i = 0; i < length; ++i) {
    for (j = 0; j < length; ++j) { 
      if (i != endIndex && j != endIndex) {
        x = (i > endIndex ? i - 1 : i);
        y = (j > endIndex ? j - 1 : j);
        
        // Be VERY careful changing anything here. We throw out anything at base pair distance 0 (endIndex) from the second structure (the target of the MFPT calculation) and maximally distant from the first structure. Because of this, there's a chunk of indices that need to get shifted to the left by one, to keep the array tight (this is what x, y are doing). Hence, x and y are used for indexing into inversionMatrix and i, j are used for indexing into transitionProbabilities.
        inversionMatrix[x * inversionMatrixRowLength + y] = (i == j ? 1 - transitionProbabilities[i][j] : -transitionProbabilities[i][j]);
      }
    }
  }
  
  inverse(inversionMatrix, inversionMatrixRowLength);
  
  for (i = 0; i < inversionMatrixRowLength; ++i) {
    for (j = 0; j < inversionMatrixRowLength; ++j) {
      mfpt[i] += inversionMatrix[i * inversionMatrixRowLength + j];
    }
  }
    
  mfptFromStart = mfpt[startIndex];
  free(mfpt);
  free(inversionMatrix);
  
  return mfptFromStart;
}

void inverse(double* A, int N) {
  // http://stackoverflow.com/questions/3519959/computing-the-inverse-of-a-matrix-using-lapack-in-c
  int *IPIV    = (int*)malloc((N + 1) * sizeof(int));
  int LWORK    = N * N;
  double* WORK = (double*)malloc(LWORK * sizeof(double));
  int INFO;

  dgetrf_(&N, &N, A, &N, IPIV, &INFO);
  dgetri_(&N, A, &N, IPIV, WORK, &LWORK, &INFO);

  free(IPIV);
  free(WORK);
}
